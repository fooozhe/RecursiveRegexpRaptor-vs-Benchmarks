#+TITLE: Comparacion del Rendimiento de Morotes de Expresiones Regulares

lang ([[readme.org][en]])

Esta obra es un derivado del post hecho por *dark100*, incluye algunos cambios
al original y un punto de visto demasiado personal de creador de dos motores
desconocidos, por fabor consulta el original aqui ->
[[http://sljit.sourceforge.net/regex_perf.html][http://sljit.sourceforge.net/regex_perf.html]]

* Introduccion

  El procesamiento de texto en bruto byte a byte, es una de las tareas mas
  comunmente realizadas por la mayoría de las herramientas de software. Dentro
  de estas tareas se suelen incluir algoritmos de busqueda de patrones, y la
  herramienta más popular para tal fin son las expresiones regulares. Las
  expresiones regulares han evolucionado mucho desde que Kleene definio los
  conjuntos regulares en la década de 1950. Hoy en día tenemos varios motores de
  expresiones regulares ampliamente usados ​​que tienen distintas [[http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines][caracteristicas]]
  que vuelven cualquier comparación de rendimiento una tarea difícil, ya que un
  motor veloz no es necesariamente *mejor*. Dependiendo del caso de uso podría
  ser suficiente conocer si es compatible con expresiones regulares POSIX para
  buscar una linea, incluso la posicion de la coincidencia es innecesaria
  (/utilidad grep/). En los demás casos cuando el uso requiere el soporte para
  la posición de captura, compatibilidad con unicode, bloque condicional y
  manipulación atómica (una secuencia de bytes como un único carácter, como
  'sch' en alemán). El primer caso necesita un algoritmo de menos sofisticado,
  que probablemente sea mucho más rápido que el segundo, pero de nuevo, eso no
  quiere decir que el primero es *mejor*. Puede encontrar más información sobre
  este tipo de motores [[http://sljit.sourceforge.net/regex_compare.html][aqui]].

* Participantes

  Los motores populores eligidos fueron:

  - [[PCRE2 10.10]]
  - [[tre 0.8.0]]
  - [[Oniguruma 5.9.6]]
  - [[re2 by Google]]
  - [[PCRE2 10.10 with sljit JIT compiler support]]

  y

  - [[https://github.com/nasciiboy/RecursiveRegexpRaptor][regexp3]]
  - [[https://github.com/nasciiboy/RecursiveRegexpRaptor-4][regexp4]]


  Antes de que nadie llegue a ninguna conclusion, debo señalar lo siguiente:

  - Los motores no estaban afinados (debido a mi falta de conocimiento sobre su
    funcionamiento interno, a excepcion de los mios regexp(3|4)). Solo los he
    compilado con las opciones predeterminadas. Si usted tiene una mejor
    configuracion por fabor enviemela y actualizare los resultados
    ([[mailto:nasciiboy@gmail]]).

  - Los motores estan compilados con la opcion =-O3= para un mejor rendimiento.

  - Esta comparacion tomo la prueba de *dark100* ([[mailto:hzmester@freemail.hu]]),
    inspirada en el trabajo de John Maddock (mira su comparacion [[http://www.boost.org/doc/libs/1_41_0/libs/regex/doc/gcc-performance.html][aqui]]). Los
    datos de entrada tambien son los mismos que el utilizo [[http://www.gutenberg.org/files/3200/old/mtent12.zip][mtent12.zip]]. Es un
    archivo de texto (e-book) con un tamaño alrededor de 20 Mbytes.

  - Solamente fueron seleccionados patrones comunes, no son casos patologicos ni
    tienen ninguna de las cualidades de Perl (regexp(3|4) solo cumplen casos
    regexp).

** Consideraciones Extra

   A diferencia de la comparacion original, /yo nasciiboy/ la realizo con la
   arrogante y egolatra intencion de demostrar que miles de lineas de codigo,
   con funciones idescifrables llenas de guiones bajos, macros misticas y una
   estructura poco clara, pueden reemplazarse por codigo sensillo y claro.

   Las librerias regexp3 y regexp4 (en fase beta) parten de zero, detras de
   ellas solo existe la funcionalidad, en buena medida por que caresco de
   fundamentos matematicos y computacionales a exepcion de un par de libros de
   programacion en C y un manual de uso de awk.

   regexp3 es la solucion mas pura, sin embargo depende exclusivamente de la
   recursividad y resuelve la exprecion a cada caracter, por ello el tiempo
   optenido es drasticamente superior al de los demas motores.

   Por su parte regexp4 primero genera una tabla con instrucciones de como
   resolver la expresion y luego recorre el texto resolviendo la tabla
   con... recursividad.

   Ambas librerias solo resuelven expresiones regulares, *no hacen uso de
   ninguna libreria externa* incluidas las librerias estandar, ni tienen
   deteccion de errores. adicionalmente cumplen con las siguientes
   caracteristicas

   regexp3 esta formada por *523* lineas de codigo, regexp4 por *705*,
   incluyendo la declaracion de muchas funciones.

* Resultados
** x86-64 bit Intel Cerelon 847 1.1GHz (GCC 6.2.1, Linux)

   #+BEGIN_HTML
     <table class="results" border="1" width="100%">
     <tbody><tr><th>Regular expression</th><th>PCRE</th><th>PCRE<br>-DFA</th><th>TRE</th><th>Onig-<br>uruma</th><th>RE2</th><th>PCRE<br>-JIT</th><th class="raptor">regexp3</th><th class="raptor">regexp4</th></tr>
     <tr><td class="pattern"><table><tr><td>.|\n</td></tr><tr><td class="raptor-pattern">.</td></tr></table></td><td class="time">4364 ms (20045118)</td><td class="time">5152 ms (20045118)</td><td class="time">6641 ms (20045118)</td><td class="time">2202 ms (20045118)</td><td class="time">7566 ms (20045118)</td><td class="time">1086 ms (20045118)</td><td class="time">1756 ms (20045118)</td><td class="time">774 ms (20045118)</td></tr>
     <tr><td class="pattern"><table><tr><td>\w</td></tr><tr><td class="raptor-pattern">:w</td></tr></table></td><td class="time">2837 ms (14751878)</td><td class="time">4292 ms (14751878)</td><td class="time">4693 ms (14751878)</td><td class="time">2243 ms (14751878)</td><td class="time">5748 ms (14751878)</td><td class="time">946 ms (14751878)</td><td class="time">1849 ms (14750958)</td><td class="time">899 ms (14750958)</td></tr>
     <tr><td class="pattern"><table><tr><td>\d</td></tr><tr><td class="raptor-pattern">:d</td></tr></table></td><td class="time">67 ms (27084)</td><td class="time">69 ms (27084)</td><td class="time">1058 ms (27084)</td><td class="time">116 ms (27084)</td><td class="time">235 ms (27084)</td><td class="time">58 ms (27084)</td><td class="time">1755 ms (27084)</td><td class="time">501 ms (27084)</td></tr>
     <tr><td class="pattern"><table><tr><td>\S</td></tr><tr><td class="raptor-pattern">:S</td></tr></table></td><td class="time">2992 ms (15451664)</td><td class="time">3280 ms (15451664)</td><td class="time">4634 ms (15451664)</td><td class="time">1851 ms (15451664)</td><td class="time">6016 ms (15451664)</td><td class="time">895 ms (15451664)</td><td class="time">1869 ms (15451664)</td><td class="time">893 ms (15451664)</td></tr>
     <tr><td class="pattern"><table><tr><td>[.\s]+</td></tr><tr><td class="raptor-pattern">[:.:s]+</td></tr></table></td><td class="time">896 ms (3430783)</td><td class="time">1089 ms (3430783)</td><td class="time">1897 ms (991813)</td><td class="time">762 ms (3430783)</td><td class="time">1774 ms (3430783)</td><td class="time">388 ms (3430783)</td><td class="time">4583 ms (3430783)</td><td class="time">1321 ms (3430783)</td></tr>
     <tr><td class="pattern"><table><tr><td>[\n.]+</td></tr><tr><td class="raptor-pattern">[\n:.]+</td></tr></table></td><td class="time">173 ms (438367)</td><td class="time">238 ms (438367)</td><td class="time">1407 ms (438367)</td><td class="time">222 ms (438367)</td><td class="time">430 ms (438367)</td><td class="time">46 ms (438367)</td><td class="time">4174 ms (438367)</td><td class="time">971 ms (438367)</td></tr>
     <tr><td class="pattern"><table><tr><td>e</td></tr><tr><td class="raptor-pattern">e</td></tr></table></td><td class="time">365 ms (1781425)</td><td class="time">451 ms (1781425)</td><td class="time">498 ms (1781425)</td><td class="time">405 ms (1781425)</td><td class="time">747 ms (1781425)</td><td class="time">136 ms (1781425)</td><td class="time">1721 ms (1781425)</td><td class="time">610 ms (1781425)</td></tr>
     <tr><td class="pattern"><table><tr><td>(((((e)))))</td></tr><tr><td class="raptor-pattern">&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1234 ms (1781425)</td><td class="time">1187 ms (1781425)</td><td class="time">496 ms (1781425)</td><td class="time">878 ms (1781425)</td><td class="time">749 ms (1781425)</td><td class="time">203 ms (1781425)</td><td class="time">26751 ms (1781425)</td><td class="time">3496 ms (1781425)</td></tr>
     <tr><td class="pattern"><table><tr><td>((((((((((e))))))))))</td></tr><tr><td class="raptor-pattern">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;e&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</td></tr></table></td><td class="time">1908 ms (1781425)</td><td class="time">1908 ms (1781425)</td><td class="time">497 ms (1781425)</td><td class="time">1162 ms (1781425)</td><td class="time">765 ms (1781425)</td><td class="time">321 ms (1781425)</td><td class="time">84651 ms (1781425)</td><td class="time">5335 ms (1781425)</td></tr>
     <tr><td class="pattern"><table><tr><td>Twain</td></tr><tr><td class="raptor-pattern">Twain</td></tr></table></td><td class="time">11 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">1021 ms (2388)</td><td class="time">53 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">51 ms (2388)</td><td class="time">4714 ms (2388)</td><td class="time">538 ms (2388)</td></tr>
     <tr><td class="pattern"><table><tr><td>(Twain)</td></tr><tr><td class="raptor-pattern">&lt;Twain&gt;</td></tr></table></td><td class="time">14 ms (2388)</td><td class="time">50 ms (2388)</td><td class="time">1010 ms (2388)</td><td class="time">53 ms (2388)</td><td class="time">8 ms (2388)</td><td class="time">51 ms (2388)</td><td class="time">9531 ms (2388)</td><td class="time">872 ms (2388)</td></tr>
     <tr><td class="pattern"><table><tr><td>(?i)Twain</td></tr><tr><td class="raptor-pattern">#*Twain</td></tr></table></td><td class="time">198 ms (2657)</td><td class="time">294 ms (2657)</td><td class="time">1311 ms (2657)</td><td class="time">399 ms (2657)</td><td class="time">261 ms (2657)</td><td class="time">53 ms (2657)</td><td class="time">4792 ms (2657)</td><td class="time">644 ms (2657)</td></tr>
     <tr><td class="pattern"><table><tr><td>((T|t)(w|W)(a|A)i([a-z]|1))</td></tr><tr><td class="raptor-pattern">&lt;&lt;T|t&gt;&lt;w|W&gt;&lt;a|A&gt;i&lt;[a-z]|1&gt;&gt;</td></tr></table></td><td class="time">615 ms (2427)</td><td class="time">534 ms (2427)</td><td class="time">1913 ms (2427)</td><td class="time">348 ms (2427)</td><td class="time">260 ms (2427)</td><td class="time">67 ms (2427)</td><td class="time">25165 ms (2427)</td><td class="time">2590 ms (2427)</td></tr>
     <tr><td class="pattern"><table><tr><td>[a-z]shing</td></tr><tr><td class="raptor-pattern">[a-z]shing</td></tr></table></td><td class="time">1434 ms (1877)</td><td class="time">2351 ms (1877)</td><td class="time">1581 ms (1877)</td><td class="time">50 ms (1877)</td><td class="time">350 ms (1877)</td><td class="time">49 ms (1877)</td><td class="time">7466 ms (1877)</td><td class="time">1447 ms (1877)</td></tr>
     <tr><td class="pattern"><table><tr><td>Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr><tr><td class="raptor-pattern">Huck[a-zA-Z]+|Saw[a-zA-Z]+</td></tr></table></td><td class="time">73 ms (396)</td><td class="time">78 ms (396)</td><td class="time">1598 ms (396)</td><td class="time">121 ms (396)</td><td class="time">225 ms (396)</td><td class="time">9 ms (396)</td><td class="time">9074 ms (396)</td><td class="time">1492 ms (396)</td></tr>
     <tr><td class="pattern"><table><tr><td>[a-q][^u-z]{13}x</td></tr><tr><td class="raptor-pattern">[a-q][^u-z]{13}x</td></tr></table></td><td class="time">1748 ms (4929)</td><td class="time">6371 ms (4929)</td><td class="time">4376 ms (4929)</td><td class="time">154 ms (4929)</td><td class="time">10241 ms (4929)</td><td class="time">5 ms (4929)</td><td class="time">15469 ms (4929)</td><td class="time">3935 ms (4929)</td></tr>
     <tr><td class="pattern"><table><tr><td>Tom|Sawyer|Huckleberry|Finn</td></tr><tr><td class="raptor-pattern">Tom|Sawyer|Huckleberry|Finn</td></tr></table></td><td class="time">97 ms (3015)</td><td class="time">104 ms (3015)</td><td class="time">2764 ms (3015)</td><td class="time">140 ms (3015)</td><td class="time">229 ms (3015)</td><td class="time">85 ms (3015)</td><td class="time">22447 ms (3015)</td><td class="time">2773 ms (3015)</td></tr>
     <tr><td class="pattern"><table><tr><td>(Tom|Sawyer|Huckleberry|Finn)</td></tr><tr><td class="raptor-pattern">&lt;Tom|Sawyer|Huckleberry|Finn&gt;</td></tr></table></td><td class="time">101 ms (3015)</td><td class="time">107 ms (3015)</td><td class="time">2789 ms (3015)</td><td class="time">142 ms (3015)</td><td class="time">229 ms (3015)</td><td class="time">83 ms (3015)</td><td class="time">38332 ms (3015)</td><td class="time">3319 ms (3015)</td></tr>
     <tr><td class="pattern"><table><tr><td>[hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo]</td></tr><tr><td class="raptor-pattern">[hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo][hHeELlLlOo]</td></tr></table></td><td class="time">612 ms (534)</td><td class="time">902 ms (534)</td><td class="time">3178 ms (534)</td><td class="time">660 ms (534)</td><td class="time">326 ms (534)</td><td class="time">244 ms (534)</td><td class="time">17300 ms (534)</td><td class="time">1637 ms (534)</td></tr>
     <tr><td class="pattern"><table><tr><td>Tom.{10,25}river|river.{10,25}Tom</td></tr><tr><td class="raptor-pattern">&lt;Tom([^(river|\n)]){10,25}river|river([^(Tom|\n)]){10,25}Tom&gt;</td></tr></table></td><td class="time">205 ms (2)</td><td class="time">260 ms (2)</td><td class="time">1773 ms (2)</td><td class="time">229 ms (2)</td><td class="time">309 ms (2)</td><td class="time">46 ms (2)</td><td class="time">41711 ms (2)</td><td class="time">1988 ms (2)</td></tr>
     <tr><td class="pattern"><table><tr><td>ing[^a-zA-Z]</td></tr><tr><td class="raptor-pattern">ing[^a-zA-Z]</td></tr></table></td><td class="time">135 ms (85956)</td><td class="time">250 ms (85956)</td><td class="time">1119 ms (85956)</td><td class="time">92 ms (85956)</td><td class="time">101 ms (85956)</td><td class="time">54 ms (85956)</td><td class="time">4067 ms (85956)</td><td class="time">574 ms (85956)</td></tr>
     <tr><td class="pattern"><table><tr><td>[a-zA-Z]ing[^a-zA-Z]</td></tr><tr><td class="raptor-pattern">[a-zA-Z]ing[^a-zA-Z]</td></tr></table></td><td class="time">1499 ms (85823)</td><td class="time">2389 ms (85823)</td><td class="time">1836 ms (85823)</td><td class="time">95 ms (85823)</td><td class="time">377 ms (85823)</td><td class="time">58 ms (85823)</td><td class="time">7917 ms (85823)</td><td class="time">1555 ms (85823)</td></tr>
     <tr><td class="pattern"><table><tr><td>([a-zA-Z]+ing)</td></tr><tr><td class="raptor-pattern">&lt;([^(ing|:A)])+ing(([^(ing|:A)])*ing)*&gt;</td></tr></table></td><td class="time">3954 ms (95863)</td><td class="time">5586 ms (95863)</td><td class="time">2081 ms (95863)</td><td class="time">2377 ms (95863)</td><td class="time">389 ms (95863)</td><td class="time">231 ms (95863)</td><td class="time">55897 ms (95863)</td><td class="time">10791 ms (95863)</td></tr>
     <tr><td class="pattern"><table><tr><td>([A-Za-z]awyer|[A-Za-z]inn)\s</td></tr><tr><td class="raptor-pattern">&lt;[A-Za-z]awyer|[A-Za-z]inn&gt;:s</td></tr></table></td><td class="time">3052 ms (313)</td><td class="time">3676 ms (313)</td><td class="time">2925 ms (313)</td><td class="time">543 ms (313)</td><td class="time">343 ms (313)</td><td class="time">106 ms (313)</td><td class="time">27720 ms (313)</td><td class="time">4402 ms (313)</td></tr>
   #+END_HTML


   Para realizar la prueba solo descarga o clona este repositor, abre un
   terminal, ejecuta =make=. y luego =runtest=. (Puedes enviarme tu resultado,
   con informacion del equipo, tu mail y un nick).

   Ultimo madificacion: 09.10.2016
